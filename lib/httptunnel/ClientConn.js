// Generated by CoffeeScript 1.8.0
(function() {
  var AutoSealDelayMs, BlockSize, ClientConn, ReqOpenIntervalMs, assert, debug, dlogSock, future, http, httpSetup, https, log, url, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  https = require("https");

  http = require("http");

  url = require("url");

  log = require("lawg");

  future = require("phuture");

  httpSetup = require("../httpSetup");

  debug = require("../debug");

  assert = require("assert");

  _ref = require("./Constants"), BlockSize = _ref.BlockSize, AutoSealDelayMs = _ref.AutoSealDelayMs, ReqOpenIntervalMs = _ref.ReqOpenIntervalMs;


  /*
  Example:
  
    conn = new ClientConn("http://server")
    conn.connect (err)->
      if not err
        console.log 'connected'
        conn.pipe(socket).pipe(conn)
  
  How it works:
    Client maintains two persistent outstanding http request:  persistent so that each request reuses the same socket.
    For send request: client is responsible to end request
    For recv request: sever is responsible to end request
   */

  if (debug.isDebug) {
    dlogSock = function(msg, socket) {
      return log("[" + (socket && socket.address() ? socket.address().port : '') + "]" + msg);
    };
  } else {
    dlogSock = function() {};
  }

  module.exports = ClientConn = (function(_super) {
    __extends(ClientConn, _super);

    function ClientConn(urlEndPoint) {
      var _base, _base1;
      this.urlEndPoint = urlEndPoint;
      ClientConn.__super__.constructor.call(this, {});
      this._sig = "httpCli";
      this.url = url.parse(this.urlEndPoint);
      if (this.url.protocol === 'https:') {
        this.doHttp = https;
        (_base = this.url).port || (_base.port = 443);
        this.sendAgent = httpSetup.createHttpsAgent({
          maxSockets: 1,
          keepAlive: true,
          keepAliveMsecs: 10000
        });
        this.recvAgent = httpSetup.createHttpsAgent({
          maxSockets: 1,
          keepAlive: true,
          keepAliveMsecs: 10000
        });
      } else {
        this.doHttp = http;
        (_base1 = this.url).port || (_base1.port = 80);
        this.sendAgent = new http.Agent({
          maxSockets: 1,
          keepAlive: true,
          keepAliveMsecs: 10000
        });
        this.recvAgent = new http.Agent({
          maxSockets: 1,
          keepAlive: true,
          keepAliveMsecs: 10000
        });
      }
    }

    ClientConn.prototype.connect = function() {
      var args, cb, headers, req, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      headers = args[0];
      if (headers == null) {
        headers = {};
      }
      headers['x-htundir'] = 'conn';
      headers['Connection'] = 'keep-alive';
      req = this.doHttp.request({
        hostname: this.url.hostname,
        port: this.url.port,
        path: this.url.path,
        method: 'GET',
        agent: false,
        headers: headers
      });
      req.on('response', (function(_this) {
        return function(res) {
          dlogSock('conn', res.socket);
          if (res.statusCode === 200) {
            _this.sessionId = res.headers['x-htunsess'];
            _this._recv();
            _this._makeSendReq();
            return cb();
          } else {
            return cb(new Error("Http conn rejected, status: " + res.statusCode + ", msg: " + (res.headers['x-htunrejectmsg'] || '')));
          }
        };
      })(this));
      req.end();
      return req.on('error', (function(_this) {
        return function(e) {
          return cb(e);
        };
      })(this));
    };

    ClientConn.prototype.end = function() {
      this._ended = true;
      return ClientConn.__super__.end.call(this);
    };

    ClientConn.prototype._read = function() {};

    ClientConn.prototype._write = function(chunk, encoding, callback) {
      if (this.sendReq._sealed) {
        this._chunk = chunk;
        this._chunkCb = callback;
        return;
      }
      this.sendReq.send(chunk);
      this.sendReq._timer.cancel();
      if (this.sendReq._n < BlockSize) {
        this.sendReq._timer = future.once(AutoSealDelayMs, (function(_this) {
          return function() {
            return _this.sendReq.seal(function() {});
          };
        })(this));
        return callback();
      } else {
        return this.sendReq.seal((function(_this) {
          return function() {
            return callback();
          };
        })(this));
      }
    };

    ClientConn.prototype._recv = function() {
      var req;
      req = this.doHttp.request({
        hostname: this.url.hostname,
        port: this.url.port,
        path: this.url.path,
        method: 'GET',
        agent: this.recvAgent,
        headers: {
          'Connection': 'keep-alive',
          'x-htunsess': this.sessionId,
          'x-htundir': 'recv'
        }
      });
      req.on('error', (function(_this) {
        return function(e) {
          return _this.emit('error', new Error("http recv " + e.toString()));
        };
      })(this));
      req.on('socket', (function(_this) {
        return function(sock) {
          return sock.setNoDelay(true);
        };
      })(this));
      req.setTimeout(ReqOpenIntervalMs * 2, (function(_this) {
        return function() {
          return req.abort();
        };
      })(this));
      req.on('response', (function(_this) {
        return function(res) {
          var n;
          res.on('error', function(e) {
            return _this.emit('error', e);
          });
          if (res.statusCode !== 200) {
            _this.emit('error', new Error("Http recv error, status: " + res.statusCode));
          }
          n = 0;
          res.on('data', function(d) {
            _this.push(d);
            dlogSock('Cli recving ' + d.length, res.socket);
            return n += d.length;
          });
          return res.on('end', function() {
            if (n > 0) {
              dlogSock('Cli recv ' + n, res.socket);
            }
            if (!_this._ended) {
              return _this._recv();
            }
          });
        };
      })(this));
      return req.end();
    };

    ClientConn.prototype._makeSendReq = function() {
      var req;
      this.sendReq = req = this.doHttp.request({
        hostname: this.url.hostname,
        port: this.url.port,
        path: this.url.path,
        method: 'POST',
        agent: this.sendAgent,
        headers: {
          'Connection': 'keep-alive',
          'Transfer-Encoding': 'chunked',
          'x-htunsess': this.sessionId,
          'x-htundir': 'send'
        }
      });
      req.on('error', (function(_this) {
        return function(e) {
          return _this.emit('error', new Error("http send " + e.toString()));
        };
      })(this));
      req.on('socket', (function(_this) {
        return function(sock) {
          return sock.setNoDelay(true);
        };
      })(this));
      req.setTimeout(ReqOpenIntervalMs * 2, (function(_this) {
        return function() {
          return req.abort();
        };
      })(this));
      req._timer = future.once(ReqOpenIntervalMs, (function(_this) {
        return function() {
          return req.seal(function() {});
        };
      })(this));
      req._n = 0;
      req.send = (function(_this) {
        return function(chunk) {
          req.write(chunk);
          dlogSock('Cli sending ' + chunk.length, req.socket);
          return req._n += chunk.length;
        };
      })(this);
      return req.seal = (function(_this) {
        return function(cb) {
          if (req._sealed) {
            return;
          }
          req._sealed = true;
          req.on('response', function(res) {
            res.on('error', function(e) {
              return _this.emit('error', e);
            });
            if (res.statusCode !== 200) {
              _this.emit('error', new Error("Http send error, status: " + res.statusCode));
            }
            res.on('data', function(d) {});
            return res.on('end', function() {
              dlogSock('Cli sent ' + req._n, res.socket);
              if (!_this._ended) {
                _this._makeSendReq();
                if (_this._chunk) {
                  _this._write(_this._chunk, null, _this._chunkCb);
                  _this._chunk = _this._chunkCb = void 0;
                }
              }
              return cb();
            });
          });
          return req.end();
        };
      })(this);
    };

    return ClientConn;

  })(require("stream").Duplex);

}).call(this);

//# sourceMappingURL=ClientConn.js.map
