// Generated by CoffeeScript 1.8.0
(function() {
  var client, config, echo_server, http, https, isSameBuf, log, makeBuf, net, path, recvEcho, req, server, spawn, wst, _log;

  (require("source-map-support")).install();

  spawn = require('child_process').spawn;

  path = require('path');

  wst = require("../lib/wst");

  net = require("net");

  _log = require("lawg");

  log = function(msg) {
    return _log(msg + "\n");
  };

  config = {
    s_port: 11001,
    t_port: 11002,
    ws_port: 11000
  };

  server = new wst.server;

  client = new wst.client;

  echo_server = null;


  /*
    client -> wsClient:s_port -> wsServer:ws_port -> echo_server:t_port
   */

  module.exports['etag header'] = function(test) {
    var d, eheader, s;
    s = {
      x: 1,
      y: 2
    };
    eheader = require("../lib/etagHeader");
    d = eheader.fromEtag(eheader.toEtag(s));
    test.equal(s.x, d.x);
    test.equal(s.y, d.y);
    return test.done();
  };

  module.exports["setup ws tunnel"] = function(test) {
    return server.start(config.ws_port, function(err) {
      test.ifError(err);
      log('ws server is setup');
      return client.start(config.s_port, "ws://localhost:" + config.ws_port, "localhost:" + config.t_port, function(err) {
        test.ifError(err);
        log("tunnel is setup");
        return test.done();
      });
    });
  };

  module.exports["setup sock echo server"] = function(test) {
    var listener;
    listener = function(conn) {
      return conn.on('data', function(data) {
        return conn.write(data);
      });
    };
    echo_server = net.createServer(listener);
    return echo_server.listen(config.t_port, function() {
      log("echo sock server is setup");
      return test.done();
    });
  };

  module.exports["test echo"] = function(test) {
    var conn;
    conn = net.connect({
      port: config.s_port
    }, function() {
      return conn.write('msg');
    });
    return conn.on('data', function(data) {
      test.equal(data, 'msg', 'echoed');
      return test.done();
    });
  };

  makeBuf = function(size) {
    var b, i, _i, _ref;
    b = new Buffer(size);
    for (i = _i = 0, _ref = size / 4; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      b.writeInt32LE(i + 1, i * 4);
    }
    return b;
  };

  isSameBuf = function(b1, b2) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = b1.length / 4; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (b1.readInt32LE(i * 4) !== b2.readInt32LE(i * 4)) {
        return false;
      }
    }
    return true;
  };

  recvEcho = function(conn, size, doneCb) {
    var rb, rbi;
    rb = new Buffer(size);
    rbi = 0;
    conn.on('data', function(data) {
      data.copy(rb, rbi);
      rbi += data.length;
      if (rbi >= size) {
        return conn.end();
      }
    });
    return conn.on('close', function() {
      return doneCb(rb);
    });
  };

  module.exports["test echo stream"] = function(test) {
    var conn, n, sb;
    n = 1000000;
    sb = makeBuf(n);
    conn = net.connect({
      port: config.s_port
    }, function() {
      return conn.write(sb);
    });
    return recvEcho(conn, n, function(rb) {
      test.ok(isSameBuf(sb, rb));
      return test.done();
    });
  };

  module.exports["test echo stream via http tunnel"] = function(test) {
    var authenticate, conn, n, sb;
    authenticate = server.authenticate;
    server.authenticate = function(httpRequest, authCb) {
      return authenticate.call(server, httpRequest, function(err, _arg) {
        var host, port;
        host = _arg.host, port = _arg.port;
        if (!('x-htundir' in httpRequest.headers)) {
          return authCb("reject websocket intentionally");
        } else {
          return authCb(err, {
            host: host,
            port: port
          });
        }
      });
    };
    n = 10033000;
    sb = makeBuf(n);
    conn = net.connect({
      port: config.s_port
    }, function() {
      return conn.write(sb);
    });
    return recvEcho(conn, n, function(rb) {
      test.ok(isSameBuf(sb, rb));
      return test.done();
    });
  };

  module.exports["test end"] = function(test) {
    test.done();
    return setTimeout(function() {
      return process.exit(0);
    }, 100);
  };

  if (require.main === module) {
    require("../lib/httpSetup").config('http://localhost:3000', true);
    https = require("https");
    http = require("http");
    req = http.request({
      hostname: 'marginalrevolution.com',
      port: 80,
      method: 'GET',
      path: '/',
      headers: {
        Host: 'marginalrevolution.com'
      }
    });
    req.on('response', function(response) {
      var body;
      body = '';
      response.on('data', function(data) {
        return body += data;
      });
      return response.on('end', function() {
        return console.log("http ok");
      });
    });
    req.end();
    req = https.request({
      hostname: 'www1.royalbank.com',
      port: 443,
      method: 'GET',
      path: 'https://www1.royalbank.com/english/netaction/sgne.html',
      headers: {}
    });
    req.on('response', function(response) {
      var body;
      body = '';
      response.on('data', function(data) {
        return body += data;
      });
      return response.on('end', function() {
        return console.log("https ok");
      });
    });
    req.end();
  }


  /*
  Some proxy strips "Upgrade: websocket" header, thus crippling websocket connection
   */

}).call(this);

//# sourceMappingURL=test.js.map
